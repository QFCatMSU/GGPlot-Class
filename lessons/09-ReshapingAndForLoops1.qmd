---
title: "09: Reshaping and For Loops 1"
# special characters for highlighting code : «»
format:
  html:
    include-in-header:
      - text: |
         <script>mod=true;</script>
---

### To-do

-   include an explanation for why ggplot with for loops are easier to debug than ggplots with melted dataframes

## Purpose

Plot multiple columns in a data frame using:

-   reshaped data frames

-   ***for*** loops

-   dealing with Lazy Evaluation

### Code for the lesson

[The script for the lesson is here](../scripts/lesson09-ReshapingAndForLoops1.R)

-   Save the R file, called ***lesson09-ReshapingAndForLoops1.R*** to the ***scripts*** folder inside your RStudio Project

 

[The data for this lesson (January Lansing temperatures from 2016-2022) is here](../Data/Jan_TAVG.csv)

-   Save the CSV file, called ***Jan_TAVG.csv*** to the ***data*** folder inside your RStudio Project. 

## A temperature matrix

To start this lesson, we are going to use a new dataset inside the ***data*** folder named [Jan_TAVG.csv](/content/DEVELOPMENT/2018/courses/DEV-belinsky-2018-GRaphingwithGGPlot/GGPlot/Lessons/../Data/Jan_TAVG.csv?isCourseFile=true).

``` r
  Jan_Avg = read.csv(file = "data/Jan_TAVG.csv");
```

***Jan_TAVG.csv*** has the average temperature for all 31 days in January in the seven years from 2016 to 2022 (31 rows by 7 columns).  The data comes from NOAA/NCDC.

### Importing the data

***Jan_TAVG.csv*** has the years in a header row as numbers in strings (e.g., "2016", "2017").

![The CSV file, Jan_TAVG.csv with years in the header row](images/GGP_1-06b_CSVFile.jpg){#fig-csvFile .fs}

 

When you read data in using ***read.csv***, the data is put into a data frame.  An "X" is added to the years in the header row  (i.e., the column names) because header rows are technically variable names and variable names cannot start with a number, so R add an "X" to make the variable name valid.  [Note: R allows invalid variable names in header rows of data frame but you should avoid this.]{.note}

 

![The Jan_Avg data frame -- with an "X" added to the years in the header row](images/GGP_1-06b_JanAvg.jpg){#fig-XinColumnName .fs}

## Plotting multiple columns

Our goal is to create a line plot for each column in the data frame in @fig-XinColumnName.

![7 lines plot, 1 for each column in Jan_Avg](images/GGP_1-06b_ForLoops.png){#fig-linePlots .fs}

## Plotting multiple columns (reshaping)

The generally accepted solution for plotting multiple columns in a data frame is to reshape the data frame.  I do not like this solution because it involves manipulating the data frame in an unintuitive and inefficient manor, but it is a widely-used technique you should be familiar with.

### Comparing original and reshaped data frame

The original data frame has 7 column with 31 row of temperature values -- so, 217 temperature values in all.

 

In the reshaped data frame, we put all 217 temperature values in one column -- [we are melting the seven temperature columns into one column]{.hl}*.*  So, the reshaped data frame will have 217 rows.

 

The original data frame (@fig-XinColumnName) has information about the year (column names: 2016-2022) and date (rows name: 1-31).  We need to maintain the year and date information in the reshaped data frame meaning [we need to create a column for the date and the year.]{.hl}

 

The reshaped data frame will have 217 rows (31\*7) and three columns: temperature, year, and date:

![The original data frame (31 rows, 7 columns) and the reshaped (melted) data frame (217 rows, 3 columns)](images/GGP_1-06b_ReshapingDataFrame.png){#fig-reshapingData .fs}

### Creating the reshaped data frame

We can use the ***reshape()*** function to create the new data frame. 

In this new data frame we need to 

-   combine the seven temperature columns into one column

-   maintain the year (old column names) and date (old row names) information in new columns

``` r
  Jan_Avg_Melt = reshape(data=Jan_Avg,        # data frame to manipulate
                    direction="long",         # how to manipulate (long form) 
                    varying=c(1:7),           # columns to combine (melt)
                    v.name="temperatures",    # name of combined column
                    times=colnames(Jan_Avg),  # old column names (years)
                    timevar = "year",         # name for new column of years
                    ids = as.numeric(rownames(Jan_Avg)),  # old row names (dates)
                    idvar = "dayNum");        # name for new column of dates
```

There are eight argument used in ***reshape()***, let's take these arguments two at a time...

 

We are reshaping the data frame ***Jan_Avg*** in the ***long*** direction (called *melting*):

``` r
data = Jan_Avg
direction="long"
```

[note: the other direction is "wide" (often called **casting**)]{#note}

 

We are combining the temperature values in columns **1** through **7:** ***c(1:7)*** and the name of the new combined column is ***temperatures***:

``` r
data = Jan_Avg
direction="long"
```

We are creating a new column from the seven column names in the old data frame (***X2016, X2017...***). The new column assigns a year to each temperature value (i.e., each row) and the new column is named **years**:

``` r
times=colnames(Jan_Avg)   #X2016, X2017...
timevar="years"
```

We are also creating a new column from the 31 row names (**1** through **31**).  The new column assigns a date to each temperature value (i.e., each row) and the new column is named ***dayNum***:

``` r
ids = as.numeric(rownames(Jan_Avg))   # same as 1:31
idvar = "dayNum"
```

### The reshaped data frame

I add this line to change the row names back to row numbers.  The line functionally does nothing but it makes the data frame easier to read in the RStudio viewer tab:

``` r
rownames(Jan_Avg_Melt) = 1:217;
```

If you open ***Jan_Avg_Melt*** (*fig \##*) you will see there are **217** rows, representing the **217** daily temperatures.  Each temperature has a day and a year associated with it and that information is reflected in the other columns of the data frame.

 

-   The ***year*** changes every 31 rows so rows **1-31** are ***X2106***, **32-62** are ***X21017***, ***63-93*** are **2018,** etc..

```         
-   The ***year*** was the column names on the original data frame ***Jan_Avg***
```

-   The ***dayNum*** cycles every 31 rows so the ***dayNum*** goes up by 1 each row and resets to ***1*** on rows **32**, **63**, **94,** **125**, **156**, and **187**.

    -   ***dayNum*** was the row names on the original data frame ***Jan_Avg***

![The reshaped data frame with the year and dayNum in their own column](images/GGP_1-06b_MeltedDF.jpg){#fig-meltedFrame .fs}

### Plotting the reshaped data frame

We can use one ***geom_line*** component to plot all seven years in the reshaped data frame.

 

The ***geom_line*** component maps:

-   ***x*** to the ***temperature*** column

-   ***y*** to the ***dayNum*** column 

-   ***color*** to the ***year*** column

The ***color*** mapping is how we create seven separate line plots -- each year is placed in the legend and mapped to a different color.

``` r
  # Plot temperature (y) ~ dayNum (x) and subset by year (color)
  plot1 = ggplot(data = Jan_Avg_Melt) +
    geom_line(mapping=aes(x=dayNum, y=temperatures, color=year));
  plot(plot1);
```

![The line plots from the reshaped data frame](images/GGP_1-06b_ReshapedPlot.png){#fig-reshapedLinePlot .fs}

## Manually create plots

The main reason I do not like the reshaping method is that it creates a new data frame that is less intuitive than the original.  I believe that the script should be manipulated to meet the needs of the data -- not the other way around.  And we have a perfectly good programming technique to cycle through, and plot, columns in a data frame: ***for*** loops.

 

We can code one ***for*** loop with one ***geom_line*** that cycled through the seven columns of the original data frame to create the seven plots.

### Manual plot with three geom_lines

We will start by plotting three of the seven columns in ***Jan_Avg***.  The code is similar to what we have done in previous lessons except the data frame, ***Jan_Avg***, is not set when we initiate the canvas (i.e., not added as ***data*** in ***ggplot()***).  Instead, we use the data frame in the ***mapping*** of the ***geoms***.  *Note: In GGPlot it is easier to use data frames in* **mapping** *when using **for** loops for reasons that would take us down a rabbit hole.*

``` r
  plot2 = ggplot() +                          «# the data frame is not declared here»
    geom_line(mapping=aes(x=1:31, 
                          y=«Jan_Avg»$X2016,  # the data frame is used here instead
                          color="2016")) +
    geom_line(mapping=aes(x=1:31,  
                          y=«Jan_Avg»$X2017,
                          color="2017")) +
    geom_line(mapping=aes(x=1:31,
                          y=«Jan_Avg»$X2018,
                          color="2018")) +
    theme_bw() + 
    labs(x = "Date",
         y = "Temp (Celsius)",
         color = "Year");
  plot(plot2);
```

There are three mapping for each ***geom_line***:

-   The ***x*** mapping for each plot is **1** through **31** since we are looking at the dates from January **1**^st^ to January **31**^st^

-   The ***y*** mapping is to the specific column of temperatures we are plotting, ***X2016,X2017***, \***X2018 ...**

-   The ***color*** mapping is the ***year***, which is hard coded in this example (a value instead of a variable). 

    -   [Note: quotes are necessary for year because year needs to be a discrete value (character), not a continuous value (numeric) -- otherwise GGPlot will try to calculate in-between values]{.note}

![Plotting 3 columns one at a time](images/GGP_1-06b_BasicPlot.png){#fig-threeColumnPlot .fs}

### Generalizing the mappings: use index numbers instead of column names

Our goal is to create code for one ***geom_line*** that can be used in a ***for*** loop to create all 7 line plots.  To do this, we need to generalize the code.

 

In a ***for*** loop, it is easier to index the columns by number instead of name (next lesson we will use names). 

 

Instead of using ***Jan_Avg\$X2016***, ***Jan_Avg\$X2017,*** and ***Jan_Avg\$X2018*** as the ***y*** mappings, we will use the **\[x,y\]** subset notation to [subset by column number instead of column name]{.hl}.

 

We provide no ***x*** value in the **\[x,y\]** subset, which means we are [taking the values from every row in the column]{.hl}

``` r
  plot3 = ggplot() +
    geom_line(mapping=aes(x=1:31, 
                          y=«Jan_Avg[,1]»,    # column 1, same as Jan_Avg$X2016
                          color="2016")) +
    geom_line(mapping=aes(x=1:31,  
                          y=«Jan_Avg[,2]»,    # column 2, same as Jan_Avg$X2017
                          color="2017")) +
    geom_line(mapping=aes(x=1:31,
                          y=«Jan_Avg[,3]»,    # column 3, same as Jan_Avg$X2018
                          color="2018")) +
    theme_bw() + 
    labs(x = "Date",
         y = "Temp (Celsius)",
         color = "Year");
  plot(plot3);
```

![plot3 looks exactly like plot2](images/GGP_1-06b_BasicPlot-01.png){#fig-threeLinesTake2 .fs}

You can put ***Jan_Avg\[,2\]*** in the ***Console*** to convince yourself that this is all values in column 2:

``` {.r tab="Console"}
> Jan_Avg[,2]
 [1]  -0.4   0.4   2.5  -4.1 -10.1 -12.8 -12.8 -11.6  -6.8   0.1   2.1   0.7  -5.8
[14]  -5.1  -4.6  -2.8   1.6   2.7   1.8   1.6   6.8   6.6   4.2   3.1   3.1   2.1  
[27]  -0.7  -2.2  -3.0  -6.8  -3.3
```

### Generalize the ***color*** mappings

The ***color*** mapping is currently [hard coded]{.hl} -- meaning ***color*** is set to a value (in quotes) instead of a variable.  We are going to change this so that the year comes from the column name.  This makes it easier to code the plot in a ***for*** loop because we can cycle through the column names using their index values:

``` r
  plot4 = ggplot() +
    geom_line(mapping=aes(x=1:31, 
                          y=Jan_Avg[,1],  
                          color=«colnames(Jan_Avg)[1]»)) +
    geom_line(mapping=aes(x=1:31,  
                          y=Jan_Avg[,2],  
                          color=«colnames(Jan_Avg)[2]»)) +
    geom_line(mapping=aes(x=1:31,
                          y=Jan_Avg[,3],  
                          color=«colnames(Jan_Avg)[3]»)) +
    theme_bw() + 
    labs(x = "Date",
         y = "Temp (Celsius)",
         color = "Year");
  plot(plot4);
```

You can put ***colnames(Jan_Avg)*** in the ***Console*** to convince yourself that is a vector with 7 value representing the seven column names:

``` {.r tab="Console"}
> colnames(Jan_Avg)
[1] "X2016" "X2017" "X2018" "X2019" "X2020" "X2021" "X2022"
```

***plot4*** will look almost exactly like ***plot2*** (*fig \##*) -- except the years in the legend are preceded with an ***X***, something we will fix later in the lesson:

![The line plot after generalizing the y and color mappings](images/GGP_1-06b_LinePlotX.png){#fig-generalizedMapping .fs}

### Generalize the ***x*** mapping

Generalizing the ***x*** mapping not necessary, but [it is good programming practice to generalize your code]{.hl} because it makes your code more flexible and easier to debug.

 

***x*** maps to the day numbers **1-31**, this is the same as the row numbers.  In GGPlot if the rows are not given names then [the row numbers are the row names]{.hl}.

 

We can see that the row names are the same as the row numbers in the ***Console***:

``` {.r tab="Console"}
> rownames(Jan_Avg)
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15" "16"
[17] "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" "30" "31"
```

The row names are put in quotes, which means *they are characters -- not numeric*.  We want the ***x*** mapping to be continuous so we need numeric values:

``` {.r tab="Console"}
> rownames(Jan_Avg)
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15" "16"
[17] "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" "30" "31"
```

We will map ***x*** to the numeric row names:

``` r
 plot5 = ggplot() +
    geom_line(mapping=aes(x=«as.numeric(rownames(Jan_Avg))»,  # 1:31
                          y=Jan_Avg[,1],    # column 1, also Jan_Avg$X2016
                          color=colnames(Jan_Avg)[1])) +
    geom_line(mapping=aes(x=«as.numeric(rownames(Jan_Avg))»,  # 1:31
                          y=Jan_Avg[,2],    # column 2, also Jan_Avg$X2017
                          color=colnames(Jan_Avg)[2])) +
    geom_line(mapping=aes(x=«as.numeric(rownames(Jan_Avg))»,  # 1:31
                          y=Jan_Avg[,3],    # column 3, also Jan_Avg$X2018
                          color=colnames(Jan_Avg)[3])) +
    theme_bw() + 
    labs(x = "Date",
         y = "Temp (Celsius)",
         color = "Year");
  plot(plot5);
```

![After generalizing the x mapping, we still have the same plot as before](images/GGP_1-06b_PlotMultColumns.png){#fig-generalizedXMap .fs}

## Using **for** loops and Lazy Evaluations

We have now generalized the script for the ***geom_line*** so that it is easier to put in a ***for*** loop.  We will now recreate the seven line plots using a ***for*** loop.

 

We will do this in three steps:

1.  Establish the ***ggplot*** canvas

2.  Add plots using a ***for*** loop to cycle through the columns

3.  Adjust the plots with ***theme*** and ***labs*** (labels)

 

[Note: Our first effort to use **for** loops will fail -- in a very instructive way that introduces Lazy Evaluations, a topic that creeps up from time to time]{.note}

### Establish the ggplot canvas

***ggplot()*** is the function that establishes a ggplot canvas.  Effectively, what ***ggplot()*** is doing is creating a ***List*** object that holds all the plot data, information, and styling.

 

We start with creating a ***List*** object with nothing in it (i.e., an empty ***ggplot()*** canvas):

``` r
plot6 = ggplot();
```

A ***List*** object named ***plot6*** has been put into the ***Environment*** and now we are going to fill it with plot data.

### Adding geoms (line plots) to the canvas

We want to create a line plot for all seven column in ***Jan_Avg***.  This means we want to cycle through the seven columns using a ***for*** loop:

``` r
for(i in 1:7)   # cycle through columns 1-7
```

And each time the ***for*** loop cycles we want to append one line plot to the canvas, ***plot6***. 

In other words, we are adding a year's line plot to ***plot6*** and saving the results back to ***plot6***:

``` r
plot6 = plot6 +
```

We need to replace the column numbers in the code from the last plot (@fig-generalizedXMap) with the indexing value in the ***for*** loop, ***i***, which goes from **1** to **7***:*

``` r
geom_line(mapping=aes(x=as.numeric(rownames(Jan_Avg)), 
                      y=Jan_Avg[,«i»],                  # columns 1-7
                      color=colnames(Jan_Avg)[«i»]));   # names from columns 1-7
```

Putting all of this together we get:

``` r
  plot6 = ggplot(); 
  
  ### Cycle through the seven columns and make a line plot for each 
  for(i in 1:7)   # cycle through columns 1-7
  {
    plot6 = plot6 + 
        geom_line(mapping=aes(x=as.numeric(rownames(Jan_Avg)), 
                              y=Jan_Avg[,i], 
                              color=colnames(Jan_Avg)[i])); 
  }
  plot(plot6);
```

And the result is something unexpected -- we only see a line plot of the last column (2022):

![Only the last column was plotted -- this is a case of Lazy Evaluation](images/GGP_1-06b_LazyEvaluation.png){#fig-lazyEval .fs}

### Lazy Evaluation 

It looks as though only the last of the seven columns was plotted once ( @fig-lazyEval) but, actually, [the last column was plotted seven times]{.hl}.

 

This happened because of the way R/GGPlot handles indexes when compiling ***for*** loops.  The compilers sees the ***for*** loop will executes seven times and stacks up the code from the seven loops like this:

``` r
    plot6 = plot6 + 
        geom_line(mapping=aes(x=as.numeric(rownames(Jan_Avg)), 
                              y=Jan_Avg[,i], 
                              color=colnames(Jan_Avg)[i])); 
    plot6 = plot6 + 
        geom_line(mapping=aes(x=as.numeric(rownames(Jan_Avg)), 
                              y=Jan_Avg[,i], 
                              color=colnames(Jan_Avg)[i])); 
    plot6 = plot6 + 
        geom_line(mapping=aes(x=as.numeric(rownames(Jan_Avg)), 
                              y=Jan_Avg[,i], 
                              color=colnames(Jan_Avg)[i])); 
   ... (4 more) ...
```

Then the compiler executed the stacked lines.  The problem is that R evaluated ***i*** after the code from the ***for*** loops was stacked.

 

But, [after the ***for*** loop,  ***i*** is equal to **7**]{.hl}.  So, R replace ***i*** with ***7*** in all seven plots in the stack.  This is called [Lazy Evaluation]{.hl}.

Lazy Evaluation is one of the more unintuitive problems that happens a lot in programming. 

## Local variables: The Lazy Evaluation fix

One solution to Lazy Evaluation is to force evaluation of ***i*** while cycling through the ***for*** loop.  This is done using ***local()***.  Inside ***local()***, we declare that ***i*** is local and needs to be evaluated now.

``` r
  #### Part 7: Stopping the Lazy Evaluation by forcing local variables
  plot7 = ggplot(); 
  
  for(i in 1:ncol(Jan_Avg))   # same as 1:7
  {
    plot7 = plot7 + 
     «local({»   # An instruction to evaluate local variables immediately
        «i=i;»   # Makes the i value local
        geom_line(mapping=aes(x=as.numeric(rownames(Jan_Avg)), 
                              y=Jan_Avg[,i], 
                              color=colnames(Jan_Avg)[i]));  
      «})»       # End the instruction to use local variables
  }
  plot(plot7);
```

This forces R to evaluate ***i*** each time through the ***for*** loop and we see the seven plots:

![Plot of all seven column after we forced local evaluation](images/GGP_1-06b_NoLazyEval.png){#fig-noLazyEval .fs}

### Alternative fix

GGPlot does have a built-in mapping function that avoids Lazy Evaluation -- ***aes\_()***.

*Note: that is **aes()** with an added underscore ( **\_** ).*

``` r
  #### Part 8: Stopping the Lazy Evaluation by using aes_()
  plot8 = ggplot(); 
  
  for(i in 1:ncol(Jan_Avg))   # same as 1:7
  { 
    plot8 = plot8 +
        geom_line(mapping=«aes_»(x=as.numeric(rownames(Jan_Avg)), 
                               y=Jan_Avg[,i], 
                               color=colnames(Jan_Avg)[i]));   
  }
  plot(plot8);
```

![plot8 is exactly the same as plot7](images/GGP_1-06b_NoLazyEval-01.png){#fig-noLAzyEval2 .fs}

### aes\_() warning

***aes\_()*** is a more elegant solution than ***local()***, but you will get a warning when using ***aes\_()***:

``` {.r tab="Console"}
Warning message:
`aes_()` was deprecated in ggplot2 3.0.0.
```

This means that GGPlot is considering removing support for ***aes\_()*** and it could stop working at some point in the future.  My guess is that it will work for a long time as there are many reasons people use ***aes\_()*** -- but, this is not a guarantee and why I teach both the ***aes\_()*** and ***local()*** methods when dealing with Lazy Evaluation.

## Appending theme and labels

Our ggplot canvas, ***plot8***, now has 7 line plots.  Let's add the ***theme*** and ***labs*** components but, instead of appending to ***plot8***, we will create a copy of ***plot8*** named ***plot9*** and append the ***theme*** and ***labs*** components to ***plot9***:

``` r
  plot9 = plot8 +
    theme_bw() + 
    labs(x = "Date",
         y = "Temp (Celsius)",
         color = "Year");
  plot(plot9);
```

![The line plots with appended theme and labs](images/GGP_1-06b_ForLoops-01.png){#fig-linePlots_For .fs}

## Aesthetic changes 

We are going to make the final plot of this lesson (@fig-linePlots_For) look a little nicer with the following changes:

1.  remove the ***X*** from the year in the legend

2.  increase the size of the line

3.  Use a better color system for the lines

 

The ***X*** can be removed from the column names and the legend using ***substring*** with the argument ***first=2***. 

``` r
  yearNum = substring(colnames(Jan_Avg), first=2);
```

***first=2*** starts with the second character ***colnames*** (i.e., removes the first character):

``` r
> yearNum
[1] "2016" "2017" "2018" "2019" "2020" "2021" "2022"
```

The size of the lines can be changed by adding the ***linewidth*** subcomponent to ***geom_line***:

``` r
      geom_line(mapping=aes_(x=as.numeric(rownames(Jan_Avg)),  # 1:31
                             y=Jan_Avg[,i], # plot temperature column i
                             color=yearNum[i]), 
                linewidth= 1.5); 
```

And we will use the ***viridis*** package to give us a better colors.  [viridis has many predefined color schemes](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) designed to increase contrast for both discrete and continuous plots.  The schemes can be access using the ***scale_color_viridis*** component:

``` r
    scale_color_viridis(discrete = TRUE, # values are discrete (FALSE: continuous)
                        option = "H",    # options are A-H, default is D
                        direction = 1) + # -1 reverses colors
```

Putting it all together (you can also use ***aes\_()*** instead of ***local()***):

``` r
  yearNum = substring(colnames(Jan_Avg), first=2);  
  
  plot10 = ggplot();   # create a new canvas
  
  for(i in 1:ncol(Jan_Avg))
  {
    plot10 = plot10 +    # append to plot8 the geom_line
      local({
        i=i;
        geom_line(mapping=aes(x=as.numeric(rownames(Jan_Avg)),  
                              y=Jan_Avg[,i],
                              color=yearNum[i]),  # change to substring
                  linewidth = 1.5);    # change the size of the line
      });
  }
 
  plot10 = plot10 +    # append these components
    theme_bw() + 
    scale_color_viridis(discrete = TRUE, # values are discrete (not continuous)
                        option = "H",    # options are A-H, default is D (Viridis)
                        direction = 1) + # -1 reverses colors
    labs(x = "Date",
         y = "Temp (\U00B0 C)",          # use unicode for the degree symbol
         color = "Year");
  plot(plot10);
```

And our new plot:

![An improved version of the plot](images/GGP_1-06b_ImprovedLines.png){#fig-improvedPlot .fs}

## Application

Create a script file in your Project's ***scripts*** folder called ***app09.r*** and using the data from ***Jan_TAVG.csv***:

1\) In comments at the top of your script answer the following:

-   What happens if you take the year out of quotes in the color mapping in ***plot2*** @fig-threeColumnPlot)?  Why? 

-   Why does the ***x*** mapping (temperature) need to be numeric and the ***color*** mapping (year) need to be a string in ***plot5*** (@fig-generalizedXMap)?  How does GGPlot plot these types of values?

 

2\) Create a line plot for the first 20 values from years 2017 to 2020 in ***Jan_TAVG.csv***--(4 line plots in all)

-   Do this once using the reshaping method

    -   You can subset the data frame in [reshape() using the argument drop](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/reshape.html)

-   And a second time using the ***for*** loops method

-   Add, and center, a title and subtitle 

-   Change the background color of the plot and the color of the axis lines to varying shades of gray using grayscale (***grey0*** to ***grey100***)

 

3\) Create a matrix from the data in ***Jan_TAVG.csv*** and create a scatterplot of each rows using ***for*** loops

-   use ***as.matrix()*** to convert the data frame into a matrix

-   Use a ***for*** loops to cycle through, and plot, all the rows (instead of columns)

 

D\) [\<Instructions for GitHub – link to previous lesson\>](01c-RStudioProjects.html#application)

### Questions

Answer the following in comments inside your application script:

1.  What was your level of comfort with the lesson/application?

2.  What is a way you can apply the material in this lesson towards your research or area of study?

3.  What are some things you would like to learn related to, but not covered in, this lesson?
